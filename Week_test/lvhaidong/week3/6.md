A 前三列不相等
通过i的for循环，创建了三个线程，每个线程调用thread_worker函数，发生cpu的使用权争夺,线程在cpu的运行是没有规律的
三个线程在执行thread_worker这个死循环之后进入到do while这个函数里，三个线程并没有结束，一直在运行中，所以每次按
回车的话，前三列的数是不断增加的，而在按q之后跳出循环，遇到了retun 0,主线程消亡，随之进程也会死亡，程序结束
B a/b的话  a是小于b的
每个线程都有自己的栈和共享的内存，对于每个线程来说，全局变量是共享的
首先main_counter是全局变量,所以每个线程在执行它的时候会发生CPU的争夺，有最好的情况和最坏的情况，最坏的情况，是三个进程完全并发
这种情况，相当于仅仅加了一次，读写会有冲突，最好的情况是完全不并发，三个线程交替执行,一个线程执行加一操作之后，另外两个线程也执行了
加一操作
另外虽然counter是全局变量，但是每个线程所对应的全局变量是不相同的，相当于TSD池的使用，一键多用，第一个线程可见的是counter[0]
第二个线程可见的是counter[1],第三个线程可见的是counter[2];
综上所说，counter的值的和大于main_contuer
C.在do循环中,三个进程仍然存在并且执行thread_worker这个函数,每按一次回车，thread_worker会被进程所执行，sum,counter和main_contuer

D.首先这种退出方式无疑是方便的，比使用pthread_join函数或者使用条件变量pthread_cond_wait函数和sleep函数更为方便，可以一次性
测试多组数据，但是它的效率并不高，在do while循环里，每次的sum都需要重置，再次执行一个for循环，在这一定程度上并不好，造成了资源
浪费，会引起其他的线程堵塞















